<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet学习笔记]]></title>
    <url>%2F2019%2F11%2F23%2FServlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ლ(•̀ _ •́ ლ) 原理图 Servlet中的生命周期方法1.被创建：执行init方法，只执行一次问题：Servlet什么时候被创建？默认情况下，第一次被访问时，Servlet被创建,可以配置执行Servlet的创建时机。在&lt;servlet&gt;标签下配置 第一次被访问时，创建&lt;load-on-startup&gt;的值为负数 在服务器启动时，创建&lt;load-on-startup&gt;的值为0或正整数 2.Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 Servlet3.0后的好处： 支持注解配置。可以不需要web.xml了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) 注意：WEB-INF目录下的资源不能被浏览器直接访问。 Servlet体系结构Servlet – 接口 |GenericServlet – 抽象类 |HttpServlet – 抽象类 1.GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * 一般开发不用hahaha 2.HttpServlet：对http协议的一种封装，简化操作(推荐) * 定义类–&gt;继承HttpServlet * 复写doGet/doPost方法 Servlet配置urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 /*: 通配符(访问级别比较低，如果有别的路径就不会访问) *.do：扩展名匹配(前面不要加 / )]]></content>
      <categories>
        <category>Javaweb</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java静态代码块static]]></title>
    <url>%2F2019%2F11%2F13%2Fjava%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97static%2F</url>
    <content type="text"><![CDATA[(′▽`〃) 静态代码块与静态方法的区别一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的;需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的. 静态方法在类加载的时候就已经加载，可以用类名直接调用。 比如：main方法就必须是静态的 这是程序入口 区别：静态代码块是自动执行的；静态方法是被调用时才执行的。 静态方法在Java里，可以定义一个不需要创建对象的方法，这种方法就是静态方法。要实现这样的效果，只需要在类中定义的方法前加上static关键字public static int minimum(int n1,int n2) 使用类的静态方法时，注意： 1.在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。2.静态方法不能以任何方式引用this和super关键字，因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。3.静态变量是属于整个类的变量而不是属于某个对象的，注意不能把任何方法体内的变量声明为静态。4.一个类可以使用不包含在任何方法体中的静态代码块，当类被载入时，静态代码块被执行，且只被执行一次，静态块常用来执行类属性的初始化。 对象的初始化顺序: 首先执行父类静态的内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有非静态代码块，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代码块。子类的非静态代码块执行完毕再去执行子类的构造方法。总之一句话，静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。 注意:子类的构造方法，不管这个构造方法带不带参数，默认的它都会先去寻找父类的不带参数的构造方法。如果父类没有不带参数的构造方法，那么子类必须用supper关键子来调用父类带参数的构造方法，否则编译不能通过。 静态变量基于一个类创建多个该类的对象，每个对象都拥有自己的属性值，互相独立。Java 中被 static 修饰的成员称为静态成员或类成员，它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问。注意：静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。优点：1.静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据。2.引用方便。直接用 类名.静态方法名 或者 类名.静态变量名就可引用并且直接可以修改其属性值，不用get和set方法。3.保持数据的唯一性。此数据全局都是唯一的，修改他的任何一处地方，在程序所有使用到的地方都将会体现到这些数据的修改，有效减少多余的浪费。4.static final用来修饰成员变量和成员方法，可简单理解为“全局常量”。对于变量，表示一旦给值就不可修改；对于方法，表示不可覆盖。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5 最长回文子串]]></title>
    <url>%2F2019%2F11%2F05%2FLeetCode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[✧(≖ ◡ ≖✿) 题目在这里 动态规划解法1234567891011121314151617181920212223242526272829class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length() &lt;= 0 || s == null) return ""; int n = s.length(); int start = 0, maxn = 1; LinkedList&lt;Character&gt; ans = new LinkedList&lt;&gt;(); int[][] dp = new int[n][n]; for(int i=0; i&lt;n; ++i) &#123; //初始化 dp[i][i] = 1; if(i&lt;n-1 &amp;&amp; s.charAt(i) == s.charAt(i+1)) &#123; dp[i][i+1] = 1; maxn = 2; start = i; &#125; &#125; for(int l=3; l&lt;=n; ++l) &#123; for(int i=0; i+l-1&lt;n; ++i) &#123; int j = i+l-1; if(s.charAt(i) == s.charAt(j) &amp;&amp; dp[i+1][j-1] == 1) &#123; dp[i][j] = 1; maxn = l; start = i; &#125; &#125; &#125; return s.substring(start, start+maxn); &#125;&#125; Manacher’s Algorithm 马拉车算法算法思想：为了解决奇数字符串和偶数字符串的问题，在每个字符串间插入“#”，为了使得扩展到边界自动结束，在两端分别插入“^”和“$”，经过处理，所求字符串的长度就永远是奇数了。 数组 P[i] 保存从中心i扩展的最大个数，同时也是去掉#后原字符串的总长度，因此只要求出 p 数组的值就能求出最长回文子串 R表示回文子串的最右边；C 表示回文子串的中心；mirror 表示 i 关于 C 的对称点 原字符开头下标 = (i - p[i])/2；R = C + p[i] 求p[i] 由于回文子串的对称性，p[i] = p[mirror] 当 p[i] 的值超过了 R，则无法利用对称性，但是p[i]至少可以扩展到 R-i (利用中心扩展法扩展) 当 p[mirror] 遇到了原字符串的左边界，p[mirror] = 1然而 p[i] 不一定遇到了边界，此时已然可以通过中心扩展法求p[i] 当 p[i] 遇到了原字符串的右边界 R，先把 p[i] 赋值为1，在通过中心扩展法求 p[i] 搞定上面的情况后还需要更新C和R 当求出的 P [i] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R，并把C改为当前i值 结合图理解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String preProcess(String s) &#123; //在每个字符串间插入“#” int n = s.length(); if (n == 0) &#123; return "^$"; &#125; String ret = "^"; for (int i = 0; i &lt; n; i++) ret += "#" + s.charAt(i); ret += "#$"; return ret;&#125;public String longestPalindrome2(String s) &#123; String T = preProcess(s); int n = T.length(); int[] P = new int[n]; int C = 0, R = 0; for (int i=1; i &lt;n-1; i++) &#123; int i_mirror = 2*C-i; if (R &gt; i) &#123; P[i] = Math.min(R-i, P[i_mirror]); // 防止超出R &#125; else &#123; P[i] = 0; // 等于R的情况 &#125; //利用中心扩展法 while (T.charAt(i+1+P[i]) == T.charAt(i-1-P[i])) &#123; P[i]++; &#125; // 判断是否需要更新 R if (i + P[i] &gt; R) &#123; C = i; R = i + P[i]; &#125; &#125; // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i=1; i&lt;n-1; i++) &#123; if (P[i] &gt; maxLen) &#123; maxLen = P[i]; centerIndex = i; &#125; &#125; int start = (centerIndex - maxLen)/2; //最开始讲的求原字符串下标 return s.substring(start, start + maxLen);&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F10%2F31%2FJDBC%2F</url>
    <content type="text"><![CDATA[(*￣(エ)￣) 加载数据库驱动1Class.forName("com.mysql.cj.jdbc.Driver"); 建立连接连接时需要提供：1.数据库端口号：3306数据库名称：nino时区设置：serverTimezone=UTC账号：root密码：admin 1Connection c = DriverManager.getConnection("jdbc:mysql://localhost:3306/nino?serverTimezone=UTC", "root", "admin"); Statement方法execute用于执行任何SQL语句，返回一个 boolean 值，表明执行该语句是否返回了 ResultSet，但它执行 SQL 语句时比较麻烦，通常我们没有必要使用 execute 方法来执行 SQL 语句，而是使用 executeQuery 或 executeUpdate 更适合 executeQuery这个方法被用来执行 SELECT 语句，它几乎是使用最多的 SQL 语句。但也只能执行查询语句，执行后返回代表查询结果的ResultSet对象。 executeUpdate用于执行 insert、update 或 delete 语句以及 SQL DDL（数据定义语言）语句，返回值是一个整数（int），指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。 ORM对象和关系数据库的映射]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode332 重新安排行程]]></title>
    <url>%2F2019%2F10%2F30%2FLeetCode332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[w(ﾟДﾟ)w 题目在这里 分析： 为了按字符顺序返回最小的行程组合，使用优先队列PriorityQueue 用深搜访问各个机场的话需要逆序放入结果集，因为会优先访问到最深的地方再返回 使用Map&lt;String, PriorityQueue&lt;String&gt;&gt;存放机场之间的连通性，这样删除边的操作和访问顺序都可以用出队操作代替 访问队列中的元素时注意判空条件temp != null &amp;&amp; !temp.isEmpty()： null只能分辨出对象是否分配内存空间，不管是否分配都不会报错 如果不分配内存空间，isEmpty会报空指针异常，主要判断PriorityQueue内容是否为空 使用addFirst方法时，不能用List interface，而要直接用LinkedList，不然会找不到addFirst方法 123456789101112131415161718192021class Solution &#123; Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;(); public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; if(tickets.size() == 0) return ans; for(List&lt;String&gt; l : tickets) &#123; //初始化map PriorityQueue&lt;String&gt; temp = map.computeIfAbsent(l.get(0), k-&gt;new PriorityQueue&lt;String&gt;()); temp.offer(l.get(1)); &#125; dfs("JFK"); return ans; &#125; public void dfs(String src) &#123; PriorityQueue&lt;String&gt; temp = map.get(src); while(temp != null &amp;&amp; !temp.isEmpty()) &#123; dfs(temp.poll()); &#125; ans.addFirst(src); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode329 矩阵中最长递增路径]]></title>
    <url>%2F2019%2F10%2F27%2FLeetCode329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[（＝。＝） 题目在这里 分析： 1.用深度优先搜索从根开始访问所有的节点2.为了避免深度优先搜索中的重复访问，可以采取记忆化的优化技术(记忆化：对于大量重复调用的问题，缓存其结果)，在这道题里，我们用temp数组来储存结果，如果已经知道相邻四个单元格的结果，就直接用，若未知，则先计算后保存至temp数组 123456789101112131415161718192021222324252627class Solution &#123; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; int n ,m; public int longestIncreasingPath(int[][] matrix) &#123; if(matrix.length &lt;= 0) return 0; n = matrix.length; m = matrix[0].length; int[][] temp = new int[n][m]; int ans = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) ans = Math.max(ans, dfs(matrix, i, j, temp)); return ans; &#125; public int dfs(int[][] matrix, int i, int j, int[][] temp) &#123; if(temp[i][j] != 0) //若已访问，直接退出 return temp[i][j]; for(int[] d : dirs) &#123; //访问上下左右的节点 int x = i+d[0]; int y = j+d[1]; if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&lt;m &amp;&amp; matrix[x][y]&gt;matrix[i][j]) temp[i][j] = Math.max(temp[i][j], dfs(matrix, x, y, temp)); &#125; return ++temp[i][j]; //加上自己 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode301 删除无效的括号]]></title>
    <url>%2F2019%2F10%2F23%2FLeetCode301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Σ( ° △ °|||)︴ 题目在这里 分析： 1.首先从左往右扫描字符串，每找到一个多余的右括号就删掉它，然后继续往后扫描2.从左往右扫描完后，将字符串反转，依然从左往右找多余的左括号并删掉3.删除的时候，记录删除的位置last，为了保证删除括号后的结果集不重复，需要检查当前位置j==last或者s.charAt(j-1) != p[1]。例如 ()())() 这组括号的第4、5个位置上的右括号删除任一个结果都是一样的。4.为了记录不同的结果集设置了for(int j=last; j&lt;=i; ++j)循环，找到一次正确的结果后回溯，寻找另一种可能的结果 12345678910111213141516171819202122232425class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;(); //存放结果集 char[] p = new char[]&#123;'(', ')'&#125;; remove(s, ans, 0, 0, p); return ans; &#125; public void remove(String s, ArrayList&lt;String&gt; ans, int start, int last, char[] p) &#123; for(int left=0, i=start; i&lt;s.length(); ++i) &#123; //删除多余的右括号 if(s.charAt(i) == p[0]) left++; if(s.charAt(i) == p[1]) left--; if(left&gt;=0) continue; for(int j=last; j&lt;=i; ++j) &#123; //为了记录不同的结果集 if(s.charAt(j) == p[1] &amp;&amp; (j==last || s.charAt(j-1) != p[1])) remove(s.substring(0, j)+s.substring(j+1, s.length()), ans, i, j, p); &#125; return; &#125; String reverse = new StringBuilder(s).reverse().toString(); if(p[1] == ')') //如果第一遍从左到右删除完毕，翻转s删除多余的左括号 remove(reverse, ans, 0, 0, new char[]&#123;')', '('&#125;); else //左右括号都删除完毕了 ans.add(reverse); &#125; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList & LinkedList]]></title>
    <url>%2F2019%2F10%2F22%2FArrayList-LinkedList%2F</url>
    <content type="text"><![CDATA[ヽ(??▽?)ノ ArrayList常用方法 方法 说明 .add(n) 增加数组元素 .add(index, n) 增加数组元素 .size() 返回数组长度 .set(index, n) 修改某个元素 .remove(n) 删除位置为n的元素，返回值指向当前被删除的对象 .get(index) 获取指定位置的对象 .indexOf(Object o) 判断对象在ArrayList所处的位置 .toArray() 把一个ArrayList对象转换为数组 .contains() 判断ArrayList是否包含指定内容 .clear() 清空ArrayList LinkedList常用方法也有add, remove, get, size等方法，还有： 方法 说明 .offer() 链尾部插入元素 .poll() 查询并移除第一个元素 .pop() 删除头元素 .peek() 获取第一个元素但是不移除 总结1.ArrayList是线性表，LinkedList是链表2.对于随机访问get,set方法，ArrayList优于LinkedList，因为LinkedList需要移动指针3.对于新增和删除方法，LinkedList占优势，因为ArrayList要移动数据]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[(๑•̀ㅂ•́)و✧ 算法原理1.从有向图中选择一个没有前驱(即入度为0)的节点并输出它。2.从图中删除这个节点，并且删除从该节点出发的所有有向边。3.重复上述两步，直到图中不再有没有前驱的顶点为止。 若所有的点都删除了，该图就是个无环图 LeetCode210 课程表II题目在这里 分析： 首先创建邻接表adj存储图的信息，inDegree储存每个节点的入度信息。初始时把入度为0的节点放入队列qu，只要队列不为空，取出队首节点并放入数组arr，依次把这个节点的所有邻接点入度-1，再次搜索入度为0的节点放入队列。直到队列为空，判断arr中的元素个数是否为总节点个数，若是，输出数组，否则拓扑失败。注意HashSet数组的定义和初始化 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; if(numCourses &lt;= 0) //判空 return new int[0]; HashSet&lt;Integer&gt;[] adj = new HashSet[numCourses]; int[] inDegree = new int[numCourses]; //保存入度的数组 LinkedList&lt;Integer&gt; qu = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;numCourses; ++i) &#123; //构建邻接表 adj[i] = new HashSet&lt;Integer&gt;(); &#125; for(int[] a : prerequisites) &#123; //初始化邻接表和入度数组 adj[a[1]].add(a[0]); inDegree[a[0]]++; &#125; for(int i=0; i&lt;numCourses; ++i) &#123; //入度为0的节点入队列 if(inDegree[i] == 0) qu.offer(i); &#125; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); while(!qu.isEmpty()) &#123; int q = qu.poll(); arr.add(q); HashSet&lt;Integer&gt; h = adj[q]; for(int i : h) &#123; //取出队列元素q后把前驱节点为q的节点的入度-1 inDegree[i]--; if(inDegree[i] == 0) //若入度为0，入队 qu.offer(i); &#125; &#125; if(numCourses == arr.size()) &#123; int[] result = new int[numCourses]; for(int i=0; i&lt;numCourses; ++i) result[i] = arr.get(i); return result; &#125; else return new int[0]; &#125;&#125; LeetCode207 课程表题目在这里还可以用dfs玩哦~ 分析： 初始化邻接表flag[i] = -1表示已经被从别的点开始的dfs确认没有环了！返回trueflag[i] = 1表示已经被当前点访问过一次了，现在是第二次，所以有环，返回false 123456789101112131415161718192021222324class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[][] adj = new int[numCourses][numCourses]; int[] flag = new int[numCourses]; for(int[] a : prerequisites) adj[a[1]][a[0]] = 1; for(int i=0; i&lt;numCourses; ++i) &#123; if(dfs(adj, flag, i) == false) return false; &#125; return true; &#125; public boolean dfs(int[][] adj, int[] flag, int i) &#123; if(flag[i] == 1) return false; if(flag[i] == -1) return true; flag[i] = 1; for(int j=0; j&lt;adj.length; ++j) &#123; if(adj[i][j] == 1 &amp;&amp; !dfs(adj, flag, j)) return false; &#125; flag[i] = -1; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List嵌套List]]></title>
    <url>%2F2019%2F10%2F13%2FList%E5%B5%8C%E5%A5%97List%2F</url>
    <content type="text"><![CDATA[b(￣▽￣)d 泛型的类型参数必须相同！ List&lt;List&lt;Integer&gt;&gt; list = new List&lt;List&lt;Integer&gt;&gt;()这种初始化方式是错误的，因为List是接口，不能实例化。 正确的做法： List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;()或List&lt;ArrayList&lt;Integer&gt;&gt; list = new List&lt;ArrayList&lt;Integer&gt;&gt;() 赋值问题 看一下LeetCode的一道题 题解： 不能直接用list.add(arr)而要list.add(newArrayList&lt;&gt;(arr)) 12345678910111213141516171819202122232425class Solution &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; if(root == null) return list; inorder(root, 0, sum); return list; &#125; public void inorder(TreeNode root, int temp, int sum) &#123; if(root == null) return; arr.add(root.val); temp += root.val; if(root.left == null &amp;&amp; root.right == null) &#123; //因为list底层数组只能保存基本类型或者对象的引用，所以不能直接add arr，不然后面 if(temp == sum) //回溯后arr就变为空了 list.add(new ArrayList&lt;Integer&gt;(arr)); //因为我们需要复用arr数组，所以不能直接调用list.add(arr)，而是应该调用ans.add(new arr.remove(arr.size()-1); //list.add(newArrayList&lt;&gt;(arr)) return; &#125; inorder(root.left, temp, sum); inorder(root.right, temp, sum); arr.remove(arr.size()-1); //回溯，将当前节点的值删除，遍历另一个分支 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治算法就是把一个复杂的问题分成两个或更多的子问题，再把子问题分成更小的子问题…直到最后子问题可以简单的直接求解。 归并排序 将数组a[n]看做n个长度为1的有序子数组(当数组长度为1时，可以认为该数组有序) 将这些子数组两两合并排序 先通过递归分解数组，再合并数组就完成了归并排序 12345678910111213141516171819202122232425262728void mergeSort(int a[], int first, int last, int temp[])&#123; if (first &lt; last) &#123; int mid = (first + last)/2; mergeSort(a, first, mid, temp); //左边归并排序 mergeSort(a, mid + 1, last, temp); //右边归并排序 mergeTwo(a, first, mid, last, temp); //再将二个有序数列合并 &#125;&#125;void mergeTwo(int a[], int first, int mid, int last, int temp[]) //合并两个有序数组&#123; int i = first, j = mid + 1; int m = mid, n = last; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= n) &#123; if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; while (i &lt;= m) temp[k++] = a[i++]; while (j &lt;= n) temp[k++] = a[j++];&#125; LeetCode23 合并k个排序链表题目在这里分析：将k个有序链表看成拥有k个数据的数组，利用归并排序的思想，将k个数据两两归并。递归分解k个链表的时候，当链表个数为1也就是区间首尾结点重合的时候，直接返回该链表；在合并两个链表的时候用到了递归的思想，当l1.val&lt;=l2.val时，l1结点数据留下来，递归判断l1.next与l2的结点值，结果储存在l1中 123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; return mergeSort(lists, 0, lists.length-1); &#125; public ListNode mergeSort(ListNode[] lists, int first, int last) &#123; if(first == last) return lists[first]; int mid = (first+last)/2; ListNode l1 = mergeSort(lists, first, mid); ListNode l2 = mergeSort(lists, mid+1, last); return mergeTwo(l1, l2); &#125; public ListNode mergeTwo(ListNode l1, ListNode l2) &#123; if(l1 == null) &#123; return l2; &#125; if(l2 == null) &#123; return l1; &#125; if(l1.val&lt;=l2.val) &#123; l1.next = mergeTwo(l1.next, l2); return l1; &#125;else &#123; l2.next = mergeTwo(l1, l2.next); return l2; &#125; &#125;&#125; 快速排序 选择一个基准数 先从右边找比这个基准数小的数放左边，然后从左开始找比这个基准数大的数放到右边 再对左右区间重复快速排序，直到区间只剩下一个数 123456789101112131415161718192021void quickSort(int s[], int first, int last)&#123; if (first &lt; last) &#123; int i = first, j = last, x = s[first]; //选取第一个数作为基准 while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) //找到了 s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) //找到了 s[j--] = s[i]; &#125; s[i] = x; //将中间的这个数和第一个数交换 quickSort(s, first, i - 1); //对左区间快速排序 quickSort(s, i + 1, last); //对右区间快速排序 &#125;&#125; 二分查找二分查找要求线性表为有序表，并且要用向量作为表的存储结构 确定中间位置 mid=(first+last)/2 待查找的key值与mid位置的值比较。若比mid位置的值大，在mid位置右边的字表中继续查找；若小于，在mid位置左边的字表中继续查找。 12345678910111213int binarySearch(int[] a, int first, int last, int key) &#123; if(key&lt;a[first] || key&gt;a[last] || first&gt;last) &#123; return -1; //查找失败 &#125; int mid = (first+last)/2; if(key == a[mid]) &#123; //查找成功，返回下标 return mid; &#125;else if(key&lt;a[mid]) &#123; return binarySearch(a, first, mid-1, key); &#125;else if(key&gt;a[mid]) &#123; return binarySearch(a, mid+1, last, key); &#125;&#125; 大整数的乘法(Karatsuba 乘法) 假设要相乘的两个数是x*y，x*y可以写成：(假设x、y的位数同为n) 例如1234可以写成a = 12，b = 34；12345可以写成a = 123，b = 45。接着x*y可以计算为： 这个式子的倒数第二步的(ad + bc)不需要另行计算，可以靠((a+b)*(c+d) - ac - bd)来重复利用前面的两次乘积结果ac、bd 拆分数据的时候要注意！因为求两数相乘的写法必须保证a、c对应的10的幂指数相同(如图x、y的写法)，我们把a、b、c、d分别拆分为[0, size1-mid]、[size1-mid]、[0, size2-mid]、[size2-mid]子串，这样保证了b、d的位数一致。举个栗子：12345 = 12*1000+345 6789 = 6*1000+789 分治的思想：这些乘法在算法里是递归实现的，当数字很大时先拆分，然后拆分出来的数字还是很大的话就继续拆分，直到x*y已经是一个很小的简单的问题。 12345678910111213141516171819// java写法public static long karatsuba(long num1, long num2)&#123; if(num1 &lt; 10 || num2 &lt; 10) //递归终止条件 return num1 * num2; // 计算拆分长度 int size1 = String.valueOf(num1).length(); int size2 = String.valueOf(num2).length(); int mid = Math.max(size1, size2)/2; // 拆分为a, b, c, d long a = Long.valueOf(String.valueOf(num1).substring(0, size1-mid)); long b = Long.valueOf(String.valueOf(num1).substring(size1-mid)); long c = Long.valueOf(String.valueOf(num2).substring(0, size2-mid)); long d = Long.valueOf(String.valueOf(num2).substring(size2-mid)); // 计算z2, z0, z1, 此处的乘法使用递归 long z2 = karatsuba(a, c); long z0 = karatsuba(b, d); long z1 = karatsuba((a + b), (c + d)) - z0 - z2; return (long)(z2 * Math.pow(10, (2*mid)) + z1 * Math.pow(10, mid) + z0);&#125; (未完待续—?)早安咕午安咕晚安咕…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>大整数乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划(dynamic programming)，简称DP一般思路：判断问题的子结构，当具有最优子结构的时候，动态规划可能适用。 一、求和最大的连续子序列求连续的子序列最大和 temp保存子序列临时最大和，temp=temp+a[i]表示以a[i]结尾的子字符串的最大和 只要temp&lt;0，就舍弃包括a[i]和之前的字符，因为负数总是拉低总和的，舍弃后令temp=0 定义maxn保存子序列最大和，如果temp&gt;maxn，就更新maxn的值 12345678910int maxn = -1;int temp = 0;for(int i=0; i&lt;n; ++i) &#123; temp = temp + a[i]; if(temp&lt;0) temp = 0; else if(temp&gt;maxn) maxn = temp;&#125;printf("%d", maxn); PTA1007 Maximum Subsequence Sum题目在这里分析：为了输出子序列最大和的初始下标和结束下标，定义初始下标leftIndex、结尾下标rightIndex、临时初始下标tempIndex当dp&lt;0时，抛弃包括a[i]和之前的字符并更新初始下标为i+1，若dp&gt;maxn，更新maxn的值后，结束下标更新为i，初始下标更新为tempIndex注意:要考虑字符全为负数的情况、字符除了含有负数之外其余为0的情况 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for(int i=0; i&lt;n; ++i) &#123; a[i] = sc.nextInt(); &#125; int leftIndex = 0; int rightIndex = n-1; int dp = 0; int tempIndex = 0; int maxn = -1; for(int i=0; i&lt;n; ++i) &#123; dp = dp+a[i]; if(dp&lt;0) &#123; dp = 0; tempIndex = i+1; &#125;else if(dp&gt;maxn) &#123; maxn = dp; rightIndex = i; leftIndex = tempIndex; &#125; &#125; if(maxn&lt;0) &#123; System.out.printf("0 %d %d",a[0], a[n-1]); &#125;else &#123; System.out.printf("%d %d %d", maxn, a[leftIndex], a[rightIndex]); &#125; &#125;&#125; (在pta运行后，最后一个测试点有运行超时的问题…我觉得这是java的错(￣﹏￣))狗头保命.jpg 二、求最长对称子串 dp[i][j]表示s[i]到s[j]的字符串是否为对称的，值为0或1 首先初始化字符串长度为1和2的dp值 dp[i][i] = 1 若s[i] = s[i+1],则dp[i][i+1] = 1，否则为0 为了保证计算dp[i][j]的时候dp[i+1][j-1]已经被计算过，我们从字符串长度L为3开始，逐步计算dp值 1234567891011121314151617int maxNum = 1; //保存最长对称子序列for(int i=0; i&lt;n; ++i) &#123; //初始化 dp[i][i] = 1; if(i&lt;n-1 &amp;&amp; s[i] == s[i+1]) &#123; dp[i][i+1] = 1; maxNum = 2; &#125;&#125;for(int L=3; L&lt;=n; ++L) &#123; for(int i=0; i+L-1&lt;n; ++i) &#123; int j = i+L-1; if(s[i]==s[j] &amp;&amp; dp[i+1][j-1]==1) &#123; dp[i][j] = 1; maxNum = L; &#125; &#125;&#125; 三、求最长不下降子序列求一个数组a[n]的最长子序列(可以不连续)，使得这个子序列是不下降的。 用dp[i]保存子序列结尾是a[i]的最大长度 对于a[i]需要判断每一个在它前面的元素a[j],当a[i]&gt;a[j] 如果dp[i]&lt;dp[j]+1，dp[i]=dp[j]+1 如果dp[i]&gt;dp[j]+1，dp[i]不变 用maxn保存最大的dp[i] 123456789int maxn = 0;for(int i=0; i&lt;n; ++i) &#123; dp[i] = 1; for(int j=0; j&lt;i; ++j) &#123; if(a[i]&gt;a[j]) dp[i] = max(dp[i], dp[j]+1); &#125; maxn = max(maxn, dp[i]);&#125; PTA1045 Favorite Color Stripe题目在这里分析：将题目转换为求最长不下降子序列的问题。order数组保存喜欢的颜色的顺序，例如order[i]=j表示颜色i的下标为j。喜欢的颜色依次存储到数组中，一个升序的序列就完成了。接下来把原有颜色序列中不喜欢的颜色剔除后放入colors数组，利用order数组将colors数组中的喜欢的颜色转换为对应的下标，这样求最长的喜欢的颜色序列就是求colors数组的最长不下降子序列了。 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] order = new int[201]; //颜色顺序 for(int i=1; i&lt;=m; ++i) &#123; int k = sc.nextInt(); order[k] = i; &#125; int L = sc.nextInt(); int[] colors = new int[L]; int num = 0; for(int i=0; i&lt;L; ++i) &#123; int k = sc.nextInt(); if(order[k]&gt;=1) //删除不喜欢的颜色 colors[num++] = order[k]; &#125; int[] dp = new int[L]; int maxn = 0; for(int i=0; i&lt;num; ++i) &#123; dp[i] = 1; for(int j=0; j&lt;i; ++j) &#123; if(colors[i]&gt;=colors[j]) dp[i] = Math.max(dp[i], dp[j]+1); &#125; maxn = Math.max(maxn, dp[i]); &#125; System.out.printf("%d", maxn); &#125;&#125; 四、求最长公共子序列给定两个字符串或数字序列a,b，求一个字符串使得这个字符串是a,b的最长公共子序列，可以不连续。 dp[i][j]表示a的第 i 位之前和b的第 j 位之前的这两个序列的最长公共子序列的长度(下标从1开始)，那么dp[a.length][b.length]即为所求 初始化dp[0][j]=0，dp[i][0]=0 若a[i] = b[j]，dp[i][j] = dp[i-1][j-1]+1 若a[i] != b[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 递推求最长公共子序列的过程： 123456789101112for(int i=0; i&lt;=a.length; ++i) &#123; dp[i][0] = 0; dp[0][i] = 0;&#125;for(int i=1; i&lt;=a.length; ++i) &#123; for(int j=1; j&lt;=b.length; ++j) &#123; if(a[i] == b[j]) dp[i][j] = dp[i-1][j-1]+1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125;&#125; 如果要求的最大公共子序列是连续的：当a[i] != b[j]时，dp[i][j] = 0 五、01背包问题给定n件物品和一个容量为C的背包，物品i的重量为w[i]，价值为v[i]。每种物品仅有一件，可以选择放与不放哦 dp[i][j]表示前i件物品中选择若干件放入容量为j的背包中所取得的最大价值 在面对第i件物品时有拿与不拿两种选择 若j&lt;w[i]，剩下的背包容量不足以装下物品i，所以dp[i][j]=dp[i-1][j] 若j&gt;=w[i]，背包可以放下物品i 如果选择拿物品i，dp[i][j]=dp[i-1][j-w[i]]+v[i] 如果不拿，dp[i][j]=dp[i-1][j] 1234567for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1, j &lt;= c; j++) if(j &gt;= w[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]); else dp[i][j] = dp[i-1][j]; &#125; 优化空间复杂度：如果只用一个一维数组dp[1…c]，需要在每次主循环中以c-&gt;1的递减顺序计算dp[j]，这样可以保证计算dp[j]时dp[j-w[i]]保存的是dp[i-1][j-w[i]]，如果是原序的话dp[j-w[i]]保存的是dp[i][j-w[i]]，与我们的目的不符。 1234for(int i = 1; i &lt;= n; i++) &#123; for(int j = c; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j-w[i]] + v[i]);&#125; 初始化的问题:1.恰好装满背包 dp[0]=0 dp[1...c]=-∞2.不需要装满背包 dp[0...c]=0分析：初始化的dp数组就是没有任何东西放入背包时的合法状态。如果要求背包恰好装满，那么只有背包容量为0的背包可以什么也不装的情况下被装满，其余的都不可能被装满必须赋值为负无穷大；如果背包不需要被装满，则任何容量的背包都可以什么都不装，所以初始状态都为0。 PTA1068 Find More Coins题目在这里分析：转换为01背包问题，把钱看成价值与重量相等的物品；为了输出最小的排列方案使用choice[i][j]数组(表示背包容量为j时是否选择i硬币)，先将钱降序排序，然后一个个的放入背包，放入背包的同时检查条件dp[i-1][j]&lt;=dp[i-1][j-v[i]]+v[i]，这个等于号很关键，由于硬币面值是从大到小排序的，加入一个新物品后可以与原价值相同，此时可能是发现了更小的组合。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;public class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] s = new int[n+1]; int[] v = new int[n+1]; for(int i=1; i&lt;=n; ++i) &#123; s[i] = sc.nextInt(); &#125; Arrays.sort(s, 1, n+1); //从小到大排序 for(int i=n, j=1; i&gt;=1; --i, ++j) v[i] = s[j]; int[][] dp = new int[n+1][m+1]; boolean[][] choice = new boolean[n+1][m+1]; for(int i=1; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=m; ++j) &#123; if(j&gt;=v[i] &amp;&amp; dp[i-1][j]&lt;=dp[i-1][j-v[i]]+v[i]) &#123; dp[i][j] = dp[i-1][j-v[i]]+v[i]; choice[i][j] = true; &#125;else dp[i][j] = dp[i-1][j]; &#125; &#125; if(dp[n][m] != m) System.out.println("No Solution"); else &#123; int[] arr = new int[n+1]; int index = n, w = m, num = 0; while(w&gt;0) &#123; if(choice[index][w] == true) &#123; arr[num++] = v[index]; w = w-v[index]; &#125; index--; &#125; System.out.printf("%d", arr[0]); for(int i=1; i&lt;num; ++i) &#123; System.out.printf(" %d", arr[i]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS & BFS]]></title>
    <url>%2F2019%2F09%2F19%2FDFS-BFS%2F</url>
    <content type="text"><![CDATA[┑(￣▽ ￣)┍ 深度优先遍历(DFS)算法的基本思想：从图的某个初始顶点v出发，首先访问初始顶点v，随后选择一个与v相邻且没访问过的点u，接着以点u为初始顶点，继续深度优先遍历，这个遍历是一个递归的过程。 12345678910int visited[MAXV] = &#123;0&#125;;void DFS(AdjGraph *G, int v)&#123; visited[v] = 1; //置v已经访问 for(循环v的每个邻接点) &#123; if(该邻接点未访问) &#123; DFS(G, 该邻接点); &#125; &#125;&#125; 嗯，好像挺简单的，做道题吧…… PTA1004 Counting Leaves题目在这里分析：用map代替邻接表储存结点信息，用一维数组levels储存每一层的叶子结点数目，只要某结点的key值对应的value值为空，则该节点为叶子结点，为了求最大深度，在每次进DFS后首先要更新最大深度。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main &#123; static int maxDepth = -1; //最大深度 static int[] levels = new int[100]; //记录每一层的叶子结点数目 public static void DFS(HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map, int node, int depth) &#123; maxDepth = Math.max(depth, maxDepth); ArrayList&lt;Integer&gt; list = map.get(node); if(list == null) &#123; //没有子节点了，跳出当前DFS levels[depth]++; return; &#125; for(Integer i : list) &#123; //有子节点时遍历子节点，找出每个子节点的子节点 DFS(map, i, depth+1); &#125; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n = sc.nextInt(); //总节点数 int m = sc.nextInt(); //叶子结点总数 HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); //用map记录结点间的父子关系 for(int i=0; i&lt;m; ++i) &#123; //初始化map int a = sc.nextInt(); int k = sc.nextInt(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j=0; j&lt;k; ++j) &#123; int b = sc.nextInt(); list.add(b); &#125; map.put(a, list); &#125; DFS(map, 1, 1); //从根结点开始(根结点深度记为1) for(int i=1; i&lt;maxDepth; ++i) //按格式输出 System.out.printf("%d ", levels[i]); System.out.printf("%d", levels[maxDepth]); &#125;&#125; 因为我总是搞不清楚递归，在这里记录一下dfs递归的过程(┬＿┬)假设输入为：5 21 2 2 32 2 4 51.首先调用DFS(1,1)，访问源点1，找源点1的邻接点2,2未被访问2.转DFS(2,2)，访问点2，最大深度更新为2，找2的邻接点4,4未被访问3.转DFS(4,3)，访问点4，最大深度更新为3，点4无子节点，第三层叶子结点个数+1，退出DFS(4,3)4.回到DFS(2,2)，继续访问2的下一个邻接点55.转DFS(5,3)，访问结点5,5无子节点，第三层叶子结点个数+1，退出DFS(5,3)6.回到DFS(2,2)，2结点的子节点全部访问完毕，退出DFS(2,2)7.回到DFS(1,1)，继续访问1的下一个子节点38.转DFS(3,2)，访问结点3，点3无子节点，第二层叶子节点数+1，退出DFS(3,2)9.回到DFS(1,1)，1结点的子节点全部访问完毕，退出DFS(1,1)递归结束！ 广度优先遍历(BFS)算法基本思想：首先访问初始点v，接着访问顶点v所有未被访问的邻接点v1,v2,v3…，然后再按照v1,v2,v3…的次序访问每一个顶点的所有未被访问的邻接点，以此类推，直到全部顶点访问完毕，需要用队列辅助。 1234567891011121314151617void BFS(AdjGraph *G, int v) &#123; 定义队列qu并初始化; 定义访问标记数组visited[MAXV]; visited[v] = 1; 访问点v; 访问后的点加入队列qu; while(qu不为空) &#123; 出队一个顶点u; for(循环查找u的每个邻接点) &#123; if(u未被访问) &#123; 访问该点; visited[u] = 1; u加入队列; &#125; &#125; &#125;&#125; 还是上一道题，换个方法做一下吧 继续PTA1004 Counting Leaves分析：多定义一个数组storey来记录各节点的层数，让当前节点的层数为父节点层数+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main &#123; static int maxDepth = -1; //最大深度 static int[] levels = new int[100]; //记录每一层的叶子结点数目 static int[] storey = new int[100]; //记录当前节点的层数 public static void BFS(HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map, int node) &#123; LinkedList&lt;Integer&gt; qu = new LinkedList&lt;&gt;(); qu.offer(node); Arrays.fill(storey, 1); while(!qu.isEmpty()) &#123; int pop = qu.poll(); maxDepth = Math.max(maxDepth, storey[pop]); if(map.get(pop) != null) &#123; for(Integer i : map.get(pop)) &#123; qu.offer(i); storey[i] = storey[pop]+1; &#125; &#125; else &#123; levels[storey[pop]]++; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n = sc.nextInt(); //总节点数 int m = sc.nextInt(); //叶子结点总数 HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); //用map记录结点间的父子关系 for(int i=0; i&lt;m; ++i) &#123; //初始化map int a = sc.nextInt(); int k = sc.nextInt(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j=0; j&lt;k; ++j) &#123; int b = sc.nextInt(); list.add(b); &#125; map.put(a, list); &#125; BFS(map, 1); for(int i=1; i&lt;maxDepth; ++i) //按格式输出 System.out.printf("%d ", levels[i]); System.out.printf("%d", levels[maxDepth]); &#125;&#125; 补充一下队列的常用方法：添加：queue.offer()、queue.add()一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。这时新的offer方法就可以起作用了。它不是对调用add()方法抛出一个unchecked异常，而只是得到由offer()返回的false。删除：queue.poll()、queue.remove()remove() 和 poll() 方法都是从队列中删除第一个元素。remove()的行为与Collection接口的版本相似，但是新的poll()方法在用空集合调用时不是抛出异常，只是返回null。因此新的方法更适合容易出现异常条件的情况。查询：queue.peek()、queue.eleement()element()和peek()用于在队列的头部查询元素。与remove()方法类似，在队列为空时，element()抛出一个异常，而peek()返回null。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法 & PTA1003 Emergency]]></title>
    <url>%2F2019%2F09%2F17%2FDijkstra%E7%AE%97%E6%B3%95-PTA1003-Emergency%2F</url>
    <content type="text"><![CDATA[(▔＾▔)/ Dijkstra最短路径问题：给定一个带权有向图G、源点v，求从源点v到图G中其他顶点的最短路径。算法的基本思想：设G=(V, E)是一个带权有向图，把图中顶点集合V分为两组，第一组为以求出最短路径的点集合S(开始时只有一个源点v，以后每求出一条最短路径v-&gt;u，就把u加入到S，直到全部顶点加入S中，算法就结束了)，第二组为未确定最短路径的顶点集合。特点：一个顶点一旦加入到S中后，其最短路径就不再改变具体步骤：1.定义一维数组dist[]存放最短路径长度(dist[j]表示源点v到j的最短路径长度)，除了可以直达的点赋初值外其余都初始化为INF(无穷大)。 初始时，S只包含源点，dist[v]=0，集合U包含除v以外的其他点，即U={其他点}，若v与U中顶点有边，则&lt;v, u&gt;有正常权值，否则为INF2.从U中选取一个距源点v最小的顶点k，加入到S中。3.加入k后，更新U中各点的最短路径，若从v点到u的距离(经过k点)比原来距离(不经过k点)短，则修改u的最短路径 4.重复2、3步骤，直到所有顶点都包含在S集合中。 举个栗子： 初始：S{0} int dist[5]={0,1,4,INF,1}加入点1后，发现1与2有边，点2的最短路径发生变化S{0,1} dist[5]={0,1,3,INF,1}加入点4后，发现3与4有边，更新3的最短路径S{0,1,4} dist[5]={0,1,3,3,1}加入点3后，2与3有边，但新的边更长，2最短路径无变化S{0,1,3,4} dist[5]={0,1,3,3,1}加入点2，最短路径无变化S{0,1,2,3,4} dist[5]={0,1,3,3,1}算法结束，最短路径求出！恭喜你学会了Dijkstra算法，让我们愉快的做一道题吧(╬▔▽▔) PTA1003 Emergency题目在这里题目主要是说，有N个城市M条路，每个城市有救援小组，每条路的长度已知，给定起点和终点，求从起点到终点的最短路径和路径上的救援队数目，如果最短路径有多条，就输出城市救援小组数目最大的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package PTAtest;import java.util.*;public class Main &#123; public static int INF = 32767; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int cityNum = s.nextInt(); //城市数量 int roadNum = s.nextInt(); //道路数量 int beg = s.nextInt(); //起点 int end = s.nextInt(); //终点 int[] cityWeight = new int[cityNum]; //各城市救援队数量 int[] roadMin = new int[cityNum]; //最短路径数目 int[] weight = new int[cityNum]; //路径上的救援队数 for(int i=0; i&lt;cityNum; ++i) cityWeight[i] = s.nextInt(); int L[][] = new int[cityNum][cityNum]; //各道路长度 for(int i=0; i&lt;cityNum; ++i) //初始化 for(int j=0; j&lt;cityNum; ++j) L[i][j] = INF; for(int i=0; i&lt;roadNum; ++i) &#123; int x = s.nextInt(); int y = s.nextInt(); int z = s.nextInt(); L[x][y] = z; L[y][x] = z; &#125; boolean[] S = new boolean[cityNum]; //判断城市是否已经在S集合中 int[] dist = new int[cityNum]; //起点到各城市最短路径长度 Arrays.fill(dist, INF); //初始化 Arrays.fill(S, false); //初始化 dist[beg] = 0; //初始化 weight[beg] = cityWeight[beg]; //初始化 roadMin[beg] = 1; //初始化 for(int i=0; i&lt;cityNum; ++i) &#123; int minDis = INF; int pos = -1; for(int j=0; j&lt;cityNum; ++j) &#123; //循环求出到源点最短的城市，加入S中 if(!S[j] &amp;&amp; dist[j]&lt;minDis) &#123; pos = j; minDis = dist[j]; &#125; &#125; if(pos == -1) break; S[pos] = true; for(int k=0; k&lt;cityNum; ++k) &#123; //每加入一个点就要考虑未加入的点的最短路径、路径救援队数、路径条数的更新 if(!S[k]) &#123; //未加入的点必须与刚加入的点有边 if(L[pos][k]&lt;INF &amp;&amp; dist[pos]+L[pos][k]&lt;dist[k]) &#123; dist[k] = dist[pos]+L[pos][k]; roadMin[k] = roadMin[pos]; weight[k] = cityWeight[k]+weight[pos]; &#125; else if(L[pos][k]&lt;INF &amp;&amp; dist[pos]+L[pos][k]==dist[k]) &#123; roadMin[k] += roadMin[pos]; if(weight[k]&lt;cityWeight[k]+weight[pos]) weight[k] = cityWeight[k]+weight[pos]; &#125; &#125; &#125; &#125; System.out.println(roadMin[end]+" "+weight[end]); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set & Map]]></title>
    <url>%2F2019%2F09%2F09%2FSet-Map%2F</url>
    <content type="text"><![CDATA[╮(╯▽╰)╭ Set1.Set集合不允许包含相同的元素，如果把两个相同的元素加入Set中会操作失败，add()方法返回false，新元素不会加入集合中。2.Set集合分为HashSet、TreeSet、EnumSet。 HashSetHashSet按哈希算法来存储集合中的元素，具有很好的查找和存取性能，特点： 元素的排列顺序可能与添加顺序不同，顺序也有可能发生变化 不是同步的(涉及多线程) 集合元素值可以是null 常用方法： 方法 描述 hashSet.add() 添加元素(返回boolean类型) hashSet.clear() 从此set中移除所有元素 hashSet.remove() 移除set中的指定元素 hashSet.isEmpty() 判断set集合是否为空，空则返回true hashSet.contains() 若set集合中包含指定元素则返回true hashSet.size() 返回set集合中的元素数量 对HashSet排序1.转换成List数组后使用Collections.sort方法进行排序2.转换成TreeSet排序 TreeSet特点：确保集合处于排序状态与HashSet相比还提供了如下一些额外的方法： 方法 描述 comparator() 定制排序(自然排序为升序) treeSet.first() 返回集合中第一个元素 treeSet.last() 返回集合中最后一个元素 treeSet.lower() 返回集合中小于指定元素的最大元素(指定元素不需要是集合里的元素) treeSet.higher() 返回集合中大于指定元素的最小元素(指定元素不需要是集合中的元素) treeSet.subSet(Object beg, Object end) 返回集合的子集合，范围：[beg, end) treeSet.headSet(Object to) 返回集合的子集，由小于to的元素构成 treeSet.tailSet(Object from) 返回集合的子集，由&gt;=from的元素构成 MapMap依次存入一对元素，以键值对的形式存在，一定要保持键的唯一性 常用方法 方法 描述 put(K key, V value) 添加元素 remove() 删除 value get(key) 获取对应key值的value boolean containsKey(Object key) 判断集合总是否包含指定的key boolean containsValue(Object value) 判断集合总是否包含指定的value java8 forEach遍历方式利用lambda表达式 12Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.forEach((k, v) -&gt; System.out.println(k + "：" + v);); computeIfAbsent()方法1234567891011121314Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); //定义一个map//如果要放一个元素进去，普通做法是先判断是否存在List&lt;String&gt; list = map.get("list1");if (list == null) &#123; list = new ArrayList&lt;&gt;(); map.put("list1", list);&#125;list.add("A");//如果用computeIfAbsent()方法,当key值为空则执行后面的lambda语句，若不为空取出与当前key匹配的list数组并add元素//变量k为map的keyList&lt;String&gt; list = map.computeIfAbsent("list1", k-&gt;new ArrayList&lt;&gt;());list.add("A");]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序]]></title>
    <url>%2F2019%2F09%2F06%2Fjava%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[ヽ(ˋ▽ˊ)ノ sort排序常用于普通数组的排序直接使用Arrays.sort(array)方法对数组array排序 按照对象属性排序一、实现comparable&lt;&gt;接口对学生类的成绩进行升序排序 1234567891011121314151617181920212223242526272829303132333435//学生类class Student implements Comparable&lt;Student&gt; &#123; String _name; //姓名 String _sno; //学号 int _grades; //成绩 Student(String name, String sno, int grades) &#123; _name = name; _sno = sno; _grades = grades; &#125; public int compareTo(Student o) &#123; return this._grades - o._grades; //升序 &#125;&#125;public class Main &#123; //主函数 public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); int i = 0; int n = s.nextInt(); s.nextLine(); while(n&gt;0) &#123; String string = s.nextLine(); String[] strs = string.split(" "); Student sts = new Student(strs[0], strs[1], Integer.parseInt(strs[2])); students.add(sts); --n; ++i; &#125; Collections.sort(students); //排序 System.out.println(students.get(students.size()-1)); System.out.println(students.get(0)); &#125;&#125; 比较器升降排序的问题：上例中return this._grades - o._grades;若return 1，true表示执行交换，则序列变为o this，o的成绩小于this，所以是升序排序综上：A&gt;B，renturn 1，true表示执行交换，所以序列变成B A，因为B小于A，所以升序。A&gt;B，return -1，false表示不执行交换，所以序列不变A B，因为A大于B，所以降序。 二、使用Comparator匿名内部类实现有时候对于一个类，对于不同的属性需要不同的排序，这时候实现接口的方法就不太灵活，而匿名内部类可以很好的帮助我们解决排序问题同上例： 123456789101112131415161718192021222324252627282930313233343536//学生类class Student &#123; String _name; //姓名 String _sno; //学号 int _grades; //成绩 Student(String name, String sno, int grades) &#123; _name = name; _sno = sno; _grades = grades; &#125;&#125;public class Main &#123; //主函数 public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); int i = 0; int n = s.nextInt(); s.nextLine(); while(n&gt;0) &#123; String string = s.nextLine(); String[] strs = string.split(" "); Student sts = new Student(strs[0], strs[1], Integer.parseInt(strs[2])); students.add(sts); --n; ++i; &#125; Collections.sort(students, new Comparator&lt;Student&gt;() &#123; public int compare(Student o1, Student o2) &#123; return o1.grades - o2.grades; &#125; &#125;); System.out.println(students.get(students.size()-1)); System.out.println(students.get(0)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一种强大的字符串处理工具,用于匹配字符串的模板 特殊字符 特殊字符 描述 $ 匹配字符串的结尾(要匹配$本身，用\$) ^ 匹配字符串的开头(要匹配^本身，用\^) () 标记一个子表达式的开始和结束位置(匹配本身，用\转义) [] 用于确定括号表达式的开始和结束位置 {} 限定前面子表达式的出现次数。eg:{n}前面的子表达式出现n次;{n, }至少出现n次或以上;{n,m}至少出现n次，至多出现m次，逗号和两个数之间不能有空格 * 指定前面的子表达式可以出现0次或多次 + 指定前面的子表达式可以出现1次或多次 ？ 指定前面的子表达式可以出现0次或1次，相当于{0,1} | 指明两项之间任选一项 预定义字符 预定义字符 描述 . 匹配除换行符\n之外的任何单字符 \d 匹配0~9的所有数字 \D 匹配一个非数字字符 \s 匹配任何空白字符，包括空格、制表符、回车符、换页符、换行符 \S 匹配所有非空白字符 \w 匹配任意一个字母、数字、下划线 \W 匹配所有的非字母、数字、下划线的字符 (未完待续？)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[String & StirngBuilder]]></title>
    <url>%2F2019%2F09%2F05%2FString%20%26%20StringBuilder%2F</url>
    <content type="text"><![CDATA[≧０≦ String常用方法 方法 说明 char charAt(int index) 获取字符串中指定位置的字符 int compareTo(String anotherstr) 比较两字符串的大小(相等时返回0，不相等时从第一个字符开始比较，返回第一个不相等的字符值差，若较长字符串前面的字符刚好是较短的字符串，则返回它们的长度差) String concat(String str) 将字符串与str连在一起 boolean equals(Object str) 将字符串与str对象比较，相同返回true，相反返回false boolean equalsIngnoreCase(String str) 与equals方法类似，忽略大小写 int indexOf(char ch) 返回ch字符在字符串中第一次出现的位置 int indexOf(char ch, int fromIndex) 返回ch字符从fromIndex开始后中第一次出现的位置 int indexOf(String str) 返回str子字符串在字符串中第一次出现的位置 int indexOf(String str, int fromIndex) 返回str子字符串从fromIndex开始后中第一次出现的位 int lastIndexOf(…) 同上(最后一次出现的位置) int length() 返回该字符串长度 String replace(char c1, char c2) 将字符串中第一个c1换成c2 String replaceAll(String regex, Stirng replacement) 将字符串中所有匹配regex的字符串替换成replacement String replaceFirst(String regex, String replacement) 将字符串中第一个匹配regex的字符串替换成replacement String subString(int beg) 返回从beg开始到结束的子字符串 String subString(int beg, int end) 返回从beg开始到end(不包括)结束的子字符串 char[] toCharArray() 将该字符串对象转换成char数组 String toLowerCase() 将字符串转换成小写 Stirng toUpperCase() 将字符串转换成大写 String valueOf(X x) 将任意基本类型转换成String对象 String[] split(“x”) 把x作为分隔符将字符串分割成多个子字符串，若有多个分隔符用|作为连字符 boolean matches(String regex) 判断该字符串是否匹配指定的正则表达式 StringBuilder初始化问题： 由于StringBuffer和String属于不同的类型，StirngBuilder sb = &quot;123&quot;是错误的，StirngBuilder sb = (StringBuilder)&quot;123&quot;也是错误的。常用方法 方法 说明 append(String s) 将指定的字符串追加到此字符序列 reverse() 将此字符序列用其反转形式取代 insert(int index, char c) 在索引值为index的位置插入指定的字符(串) delete(int startIndex,int endIndex) 删除起始位置(含)到结尾位置(不含)之间的字符串 toString() 返回String类型的字符串 replace(char oldChar, char newChar) oldChar为待替换字符(串)，newChar为新替换的字符(串) 区别1.如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer更加适合。2.StirngBuilder在进行字符串处理时，不生成新的对象，每次修改都会改变对象自身，内存上优于String。3.StirngBuilder是线程不安全的，StirngBuffer是线程安全的。二者方法基本一样。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树排序]]></title>
    <url>%2F2019%2F08%2F17%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[性能：二叉树排序&gt;选择排序&gt;冒泡排序 向英雄二叉树中插入不同的Hero对象，按照Hero的血量排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package Hello;import java.util.*;class Hero &#123; double _hp; //英雄血量 String _name; //英雄名称 Hero(String name, double hp) &#123; _name = name; _hp = hp; &#125; public String toString() &#123; return "名称："+_name+"血量："+_hp; &#125;&#125;class HeroNode &#123; HeroNode _leftNode; //左节点 HeroNode _rightNode; //右节点 Hero hero; void add(Hero v) &#123; //加入结点 if(hero == null) &#123; hero = v; &#125; else &#123; if(hero._hp&gt;=v._hp) &#123; if(_leftNode == null) &#123; _leftNode = new HeroNode(); &#125; _leftNode.add(v); &#125; else &#123; if(_rightNode == null) &#123; _rightNode = new HeroNode(); &#125; _rightNode.add(v); &#125; &#125; &#125; ArrayList&lt;Hero&gt; values() &#123; //中序遍历二叉树 ArrayList&lt;Hero&gt; hs = new ArrayList&lt;&gt;(); if(_leftNode != null) &#123; //若左子树不为空 hs.addAll(_leftNode.values()); //中序遍历左子树，遍历过的结点加入hs数组中 &#125; hs.add(hero); //遍历根结点 if(_rightNode != null) &#123; //若右子树不为空 hs.addAll(_rightNode.values()); //中序遍历右子树 &#125; return hs; &#125;&#125;public class HelloWorld &#123; public static void main(String[] args) &#123; ArrayList&lt;Hero&gt; heros = new ArrayList&lt;&gt;(); for(int i=0; i&lt;10; ++i) &#123; //初始化10个Hero对象 heros.add(new Hero("hero "+i, (double)(Math.random()*1000))); &#125; HeroNode h = new HeroNode(); for(Hero o : heros) &#123; //调用add方法插入Hero对象 h.add(o); &#125; System.out.println(h.values()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java ConcurrentModificationException异常]]></title>
    <url>%2F2019%2F08%2F16%2FJava-ConcurrentModificationException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[问题原因使用迭代器遍历的同时又增加或删除元素，就会出现异常。 解决办法错误的代码: 该代码首先初始化一个Hero集合，里面放100个Hero对象，然后通过遍历的手段删除名字编号是8的倍数的对象。解决方法：使用ListIterator就ok了。如图： 补充一些知识点：1.substring()方法：返回字符串的子字符串。 1234public String substring(int beginIndex)public String substring(int beginIndex, int endIndex)//beginIndex--起始索引(包括)，索引从0开始。//endIndex--结束索引(不包括)。 2.parseInt()方法： 123456789101112131415parseInt(String str); //返回用十进制参数表示的整数值parseInt(String str, int i); //使用指定基数的字符串参数表示的整数(基数可以是2,8,10,16等进制数)//str--十进制表示的字符串，i--指定的基数/**********例子**********/public class Test&#123; public static void main(String[] args)&#123; int x =Integer.parseInt("8"); double y = Double.parseDouble("8"); int z = Integer.parseInt("88",16); System.out.println(x); System.out.println(y); System.out.println(z); &#125;&#125; 以上例子的输出结果：]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成随机字符串数组并排序]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[使用冒泡排序法 冒泡排序：相邻两个数进行比较，n个数比较n-1趟，第i趟比较n-i-1次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Hello;import java.util.*;public class HelloWorld &#123; public static String randomString(int length) &#123; //生成随机字符串 char[] ch = new char[length]; for(int i=0; i&lt;ch.length; ++i) &#123; while(true) &#123; char c = (char)(Math.random()*75+48); if(Character.isLetter(c)||Character.isDigit(c)) &#123; ch[i] = c; break; &#125; &#125; &#125; return String.valueOf(ch); &#125; public static void main(String[] args) &#123; String[] str = new String[8]; for(int i=0; i&lt;str.length; ++i) &#123; str[i] = randomString(5); &#125; System.out.println("未排序前的数组："); System.out.println(Arrays.toString(str)); for(int i=0; i&lt;str.length-1; ++i) &#123; //冒泡排序(不区分大小写) for(int j=0; j&lt;str.length-i-1; ++j) &#123; char firstch1 = str[j].charAt(0); char firstch2 = str[j+1].charAt(0); firstch1 = Character.toLowerCase(firstch1); firstch2 = Character.toLowerCase(firstch2); if(firstch1&gt;firstch2) &#123; String temp = str[j]; str[j] = str[j+1]; str[j+1] = temp; &#125; &#125; &#125; System.out.println("排序后的数组："); System.out.println(Arrays.toString(str)); &#125;&#125; 运行结果： char与String的相互转换 String转换为char String.charAt(index) (返回值为char) 可以得到String中某一指定位置的char。 String.toCharArray() (返回值为char[]) 可以得到包含整个String的char数组，这样就可以用下标访问Stirng中任意位置的元素。 char转换为String String str = String.valueOf(&#39;c&#39;); String str = Character.toString(&#39;c&#39;); String str = String valueOf(new char[] ch);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++学习笔记]]></title>
    <url>%2F2019%2F07%2F11%2Fc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[good good studyday day up 批量注释快捷键：Ctrl+k+c取消注释：Ctrl+k+u 随机函数rand()和srand()用法rand()头文件：#include&lt;cstdlib&gt;功能：rand返回一随机数值0~32767之间，随机数种子默认为1。相同的随机数种子产生的随机数也相同，因此rand产生的是伪随机数。想要rand每次执行产生不同的随机数吗？ 那就用srand函数吧！ srand()头文件：#include&lt;cstdlib&gt;功能：srand()用来设置rand()产生随机数时的随机数种子用法：参数seed必须是个整数，通常可以利用time(0)的返回值或NULL来当做seed。(注意：time函数要使用time.h头文件)程序例： 1234567891011121314151617#include&lt;iostream&gt;#include&lt;time.h&gt; //包含函数time的头文件#include&lt;cstdlib&gt; //包含函数rand和srand的头文件using namespace std;int main()&#123; int i; srand(time(0)); cout &lt;&lt; "Ten random numbers from " //产生0-99之间的随机数 &lt;&lt; "0" &lt;&lt; " to " &lt;&lt; "99" &lt;&lt; endl; for (i = 0; i &lt; 10; ++i) //产生10个随机数 cout &lt;&lt; rand() % 98 &lt;&lt; "\t"; cout &lt;&lt; endl; return 0;&#125; 结果： (注：srand一定要放在循环的外面) 产生一定范围内的随机数通用表达式a+rand()%n (其中a是起始值，n是整数的范围) vector的用法 vector是一种动态数组，其内部定义了很多基本操作，使用它时需要包含头文件#include&lt;vector&gt; vector的初始化 形式 说明 vector&lt;int&gt; a; 声明一个int型向量a(尖括号中为元素类型名。它可以是任何合法的数据类型) vector&lt;int&gt; a(10); 声明一个初始大小为10的向量，没有给定初值，其值不确定 vector&lt;int&gt; a(10, 1); 声明一个初始大小为10且初值都为1的向量 vector&lt;int&gt; b(a); 用向量a初始化向量b，整体复制性赋值 vector&lt;int&gt; b(a.begin(), a.begin()+3); 向量a中从第0个到第2个(共3个)为b向量赋初值 除此之外，还可以用数组初始化vector 123int b[]=&#123;1, 2, 3, 4, 5&#125;;vector&lt;int&gt; a(b, b+5); //将数组b的前五个元素作为向量a的初值vector&lt;int&gt; a(&amp;b[0], &amp;b[4]); //同理 vector的操作方法 方法 说明 a.assign(b.begin(), b.end()) 将begin到end区间内的数据赋值给a a.assign(n, elem) 向量a含n个元素，每个元素值为elem a.at(ai) 传回索引ai所指向的数据，如果ai越界，抛出out_of_range异常 a.back() 传回最后一个数据，不检查这个数据是否存在 a.begin() 返回一个迭代器，它指向容器a的第一个元素 a.capacity() 返回容器中数据个数 a.clear() 清空容器中所有数据 a.empty() 判断容器是否为空 a.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置 a.erase(pos) 删除pos位置的数据，传回下一个数据的位置 a.erase(beg, end) 删除[beg, end)位置的数据，传回下一个数据的位置 a.front() 传回第一个数据 a.insert(pos, elem) 在pos位置插入elem元素，传回新数据位置 a.insert(pos, n, elem) 在pos位置插入n个elem元素，无返回值 a.insert(pos, beg, end) 在pos位置插入[beg, end)区间的数据，无返回值 a.max_size() 返回容器中最大数据的数量 a.pop_back() 删除最后一个数据 a.push_back(elem) 在尾部加入一个elem数据 a.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素 a.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置 a.reserve(num) 保留适当的(num个)容量，可以避免多次内存扩充操作(当a的容量不足时电脑会自动扩容，这样会降低性能) a.resize(num) 将容器a现有的元素个数调整至num个，多则删少则补(补的值随机) a.resize(num, elem) 将容器a现有的元素个数调整至num个，多则删少则补(补值为elem) a.size() 返回容器中实际数据的数量 a.swap(b) 容器a,b中的元素进行整体性交换 (未完待续…)]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Markdown写好一篇hexo博客]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99%2F</url>
    <content type="text"><![CDATA[Markdown基础语法 标题Markdown支持6种级别的标题一个#是一级标题，二个#是二级标题… 注意！ #后面需要跟一个空格 eg: # 这里写一级标题 ## 这里写二级标题 ### 这里写三级标题 #### 这里写四级标题 ##### 这里写五级标题 ###### 这里写六级标题 效果图： 插入图片的问题hexo博客并不支持markdown格式的插入图片！1.将根目录的_config.yml文件中的post_asset_folder: false设置为true2.输入指令npm install hexo-asset-image --save下载插件3.Hexo将会在你每一次通过 hexo n命令创建新文章时自动创建一个文件夹。这个文件夹会有与这个文件一样的名字。然后把你想插入的图片放到这个文件夹里面。4.正确的引用图片的方式是( {和%之间没有空格 )：{ % asset_img example.jpg This is an example image % } 字体粗体：把需要加粗的文字左右用**括起来斜体：把需要倾斜的文字左右用*括起来删除线：把想划掉的文字左右用~~括起来斜体加粗：把需要的文字左右用***括起来下划线：通过HTML的&lt;u&gt;标签来实现(&lt;/u&gt;结束) 链接格式：[对链接的描述](链接) 代码代码块上下分别用三个` 符号包裹起来(`符号在Esc键的下面)，然后每行缩进四个空格或一个制表符即可代码行左右分别用一个` 符号包裹起来(`符号在Esc键的下面)。 引用格式：&gt;引用的内容(引用可以嵌套，前面可以根据需要添加n个&gt;)例如：&gt;哈喽&gt;&gt;哈喽&gt;&gt;&gt;哈喽 列表无序列表(以下二种都可以，符号与内容之间要有一个空格！)：- 列表内容+ 列表内容 有序列表1.列表内容2.列表内容3.列表内容 列表嵌套格式：下一级每行缩进三个空格即可例如： 动物 猪猪 二哈 表格语法：第二行分割表头和内容，-符号可以随便加几个，表格内文字默认居左(-两边加：表示文字居中)(-右边加：表示文字居右) 表头|表头|表头 ----|----|---- 内容|内容|内容 内容|内容|内容效果如下： 注意：表格开头结尾最好与上下文隔开一行，不然会显示不正常(奇怪.jpg) 流程图 建议用别的软件画吧 表情包的使用1.首先安装插件npm i hexo-tag-emojis-byhj --save2.可以在文章内引入css样式控制一下图片大小之类的，请自由发挥例如: 1&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/honjun/hexo-tag-emojis-byhj/css/emoji.css"&gt; 3.使用emoji语法如下(举个例子) {% emoji_hj people/face-with-tears-of-joy %} 这里引用作者 hojun 2019-04-05制作的表情包页面目前所有的表情在这个页面直接点击表情就能复制相应的代码，粘贴到自己文章中，耍起来就很方便了。 更改字体、颜色、大小&lt;font face=&quot;你想要的字体&quot; color=颜色代码 size=字体大小&gt;某个字&lt;/font&gt;想找颜色代码点这里实例：&lt;font color=#ffff00 face=&quot;微软雅黑&quot;&gt;你好&lt;/font&gt; 某些问题1.如果某些内容导致文章中的处理问题，可以用raw标签包裹它例如： 123&#123;% raw %&#125;content&#123;% endraw %&#125; 2.尖括号里的东西好像不会显示出来，&lt;前面加上\吧 hexo内置标签标签是hexo提供的一种快速生成特定内容的方式。 文本居中的引用12345&#123;% cq %&#125;富强、民主、文明、和谐自由、平等、公正、法治爱国、敬业、诚信、友善&#123;% endcq %&#125; 效果： note标签1234567891011121314151617181920212223&#123;% note %&#125;Content (md partial supported) &#123;% endnote %&#125;&#123;% note danger %&#125;Content (md partial supported) &#123;% endnote %&#125;&#123;% note info %&#125;Content (md partial supported) &#123;% endnote %&#125;&#123;% note warning %&#125;Content (md partial supported) &#123;% endnote %&#125;&#123;% note success %&#125;Content (md partial supported) &#123;% endnote %&#125;&#123;% note primary %&#125;Content (md partial supported) &#123;% endnote %&#125; 效果： label标签@后面是要显示的文字 123456&#123;% label default@哈哈哈 %&#125;&#123;% label primary@啦啦啦 %&#125;&#123;% label success@呼呼呼 %&#125;&#123;% label info@嗷嗷嗷 %&#125;&#123;% label warning@呸呸呸 %&#125;&#123;% label danger@噗噗噗 %&#125; 效果： 哈哈哈 啦啦啦 呼呼呼 嗷嗷嗷 呸呸呸 噗噗噗 选项卡(tabs标签)12345678&#123;% tabs, 2 %&#125; //, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容&lt;!-- tab 选项卡1@home --&gt; //@heart是爱心小图标大胆刁民&lt;!-- endtab --&gt;&lt;!-- tab 选项卡2--&gt;大佬们好呀\(▔▽▔)/&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
